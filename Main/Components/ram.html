<!doctype html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RAM</title>
    <link rel="stylesheet" href="../style.css" />
    <link rel="stylesheet" href="comp.css" />
</head>

<body>
    <nav>
        <a href="../index.html">Start</a> |
        <a href="../Main/main.html" class="active-link">Main</a> |
        <a href="../General/general.html">General info</a>
    </nav>

    <div class="container">
        <div class="header">
            <div>
                <h1>RAM</h1>
                <p>
                    La <strong>RAM</strong> est la mémoire de travail du microcontrôleur. Elle stocke les
                    <strong>variables</strong>, les <strong>buffers</strong> et la <strong>pile</strong> (stack).
                    Elle est <strong>volatile</strong>: quand l’alimentation est coupée, les données disparaissent.
                </p>
            </div>
            <div class="badge"><span class="dot"></span> Mémoire de travail</div>
        </div>

        <div class="grid">
            <section class="card">
                <h2>Rôle dans le système: pourquoi et comment</h2>
                <p>
                    Le CPU a besoin d’un endroit rapide pour manipuler des données qui changent en permanence:
                    mesures de capteurs, états, compteurs, messages reçus, etc. C’est exactement le rôle de la RAM.
                </p>
                <p>
                    Sur un MCU, la RAM est souvent limitée. Cela force à programmer de manière efficace:
                    éviter des tableaux trop grands, gérer les buffers correctement, et faire attention à la pile.
                    La RAM est aussi essentielle pour les communications: réception UART, trames I2C, buffers SPI, etc.
                </p>

                <div class="kv">
                    <div class="k">Contient</div>
                    <div class="v">Variables, buffers, pile (stack), états</div>
                    <div class="k">Volatile ?</div>
                    <div class="v">Oui (perdu à l’extinction)</div>
                    <div class="k">Risque</div>
                    <div class="v">Dépassements, pile trop petite, bugs “bizarres”</div>
                </div>
            </section>

            <section class="card">
                <h2>Exemple concret</h2>
                <p>
                    Un capteur est lu 100 fois par seconde. La dernière valeur est stockée en RAM et
                    utilisée pour ajuster une sortie PWM (ex: luminosité LED ou vitesse moteur).
                </p>
                <div class="code">
                    valeur = lire_ADC();<br />
                    pwm = convertir(valeur);<br />
                    appliquer_PWM(pwm);
                </div>
            </section>

            <section class="card">
                <h2>Plus de détails</h2>
                <p>
                    En C/C++, la RAM contient notamment les variables globales, les variables locales (sur la pile),
                    et les buffers utilisés par les périphériques. Quand on appelle une fonction, la pile stocke
                    l’adresse de retour et des variables temporaires.
                </p>
                <p>
                    Si la pile déborde (stack overflow), le programme peut se comporter de manière imprévisible:
                    redémarrages, valeurs incohérentes, blocage. C’est une différence importante avec un PC
                    où les ressources sont beaucoup plus grandes.
                </p>
                <p>
                    Une bonne pratique en embarqué: garder des structures simples, mesurer l’usage de mémoire,
                    éviter les allocations dynamiques inutiles, et faire attention aux buffers de communication.
                    En projet, le plus important est de retenir que la RAM est petite mais vitale: tout le “travail”
                    passe par elle.
                </p>
                <p>
                    Enfin, la RAM sert aussi à stocker des “états” (machine à états): par exemple, ATTENTE → MESURE →
                    ENVOI.
                    Ça rend le code plus robuste et plus lisible, car le MCU ne fait pas tout en même temps, il suit un
                    plan clair.
                </p>
            </section>

            <section class="card tldr">
                <h2>TL;DR (à retenir)</h2>
                <p>
                    La RAM est la <strong>mémoire temporaire</strong> où le MCU stocke les variables et buffers pendant
                    l’exécution.
                    Elle est rapide mais souvent limitée, et elle est perdue à l’extinction. Beaucoup de bugs en
                    embarqué
                    viennent d’une mauvaise gestion de la RAM (buffers/pile).
                </p>
                <ul>
                    <li><strong>Volatile</strong>: données perdues sans alimentation.</li>
                    <li><strong>Essentielle</strong>: variables, buffers, pile.</li>
                    <li><strong>Limitée</strong>: attention aux tableaux et aux chaînes.</li>
                    <li><strong>Pièges</strong>: overflow, pile trop petite, instabilité.</li>
                </ul>

                <div class="footer-links">
                    <a class="btn" href="../Main/main.html">← Retour au schéma</a>
                    <a class="btn" href="rom.html">Suivant: ROM/Flash →</a>
                </div>
            </section>
        </div>
    </div>
</body>

</html>